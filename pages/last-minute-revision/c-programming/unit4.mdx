# Functions and Pointers

## 1. Functions

### A Brief Overview

- Functions are reusable blocks of code designed to perform a specific task. They help in modularizing programs, making them easier to read and maintain.

### Defining a Function

- A function is defined by its return type, name, and parameters. The syntax is:

```c
return_type function_name(parameter_list) {
    // body of the function
}
```

- **Example**:

```c
int add(int a, int b) {
    return a + b;  // Returns the sum of a and b
}
```

### Accessing a Function

- Functions can be called by their name followed by parentheses. You can pass arguments to the function inside the parentheses.
- **Example**:

```c
int result = add(5, 10); // Calls the add function
```

### Function Prototypes

- A function prototype declares the function's name, return type, and parameters before its actual definition. This is useful for informing the compiler about the function before it is used.
- **Example**:

```c
int add(int, int); // Prototype
```

### Passing Arguments to a Function

- There are two ways to pass arguments:
  - **Pass by Value**: A copy of the variable is passed. Changes made inside the function do not affect the original variable.
    - **Example**:
    ```c
    void modify(int x) {
        x = x + 10; // This does not affect the original variable
    }
    ```
  - **Pass by Reference**: The address of the variable is passed. Changes made inside the function affect the original variable.
    - **Example**:
    ```c
    void modify(int *x) {
        *x = *x + 10; // This modifies the original variable
    }
    ```

### Recursion

- Recursion occurs when a function calls itself. It requires a base case to stop the recursion and prevent infinite loops.
- **Example**:

```c
int factorial(int n) {
    if (n == 0) return 1;  // Base case
    return n * factorial(n - 1);  // Recursive call
}
```

---

## 2. Pointers

### Fundamentals

- Pointers are variables that store the memory address of another variable. They provide a way to manipulate memory directly, which is useful for dynamic memory allocation and efficient array handling.

### Pointer Declarations

- A pointer is declared by placing an asterisk (\*) before the pointer's name.
- **Example**:

```c
int *ptr; // Pointer to an integer
```

### Passing Pointers to Functions

- Pointers can be passed to functions, allowing functions to modify the original variable.
- **Example**:

```c
void updateValue(int *p) {
    *p = 100; // Modify the value at the address pointed to by p
}
```

### Pointers and One-Dimensional Arrays

- The name of an array acts as a pointer to its first element. This allows easy manipulation of array elements using pointers.
- **Example**:

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr; // ptr points to the first element of arr
```

### Dynamic Memory Allocation

- C provides functions to allocate memory dynamically at runtime. The most common functions are `malloc()`, `calloc()`, and `free()`.
- **Example**:

```c
int *arr = (int*)malloc(5 * sizeof(int)); // Allocates memory for 5 integers
if (arr == NULL) {
    // Handle memory allocation failure
}
```

### Operations on Pointers

- Pointers can be incremented or decremented to traverse arrays. The pointer arithmetic takes the data type size into account.
- **Example**:

```c
int arr[3] = {10, 20, 30};
int *ptr = arr; // ptr points to arr[0]
ptr++; // Now ptr points to arr[1]
```

### Arrays of Pointers

- You can create an array where each element is a pointer. This is particularly useful for storing strings (arrays of characters).
- **Example**:

```c
char *names[3] = {"Alice", "Bob", "Charlie"}; // Array of string pointers
```
